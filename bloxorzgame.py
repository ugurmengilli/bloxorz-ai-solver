"""
Author: Ugur Mengilli

Bloxorz Game implemented as an AI problem
"""
import bloxorzutils
from aima.search import Problem


class BloxorzGame(Problem):
    """
    Implements the game as AI Problem and defines the game rules, internal representations and interfaces for further
    usage of the class.
    """

    _BLOCK_VAL = 2
    _GOAL_VAL = -1

    @staticmethod
    def decoder_gen(empty='X', safe='O', block='S', goal='G',
                    col_sep=' ', row_sep='\n'):
        """
        Generate a custom/default decoder needed to translate str representation of a map into tiles.
        :param empty: The block cannot go into an empty tile, even partially.
        :param safe: The block can stand on safe tile at any time at any orientation.
        :param block: Denotes the tile(s) occupied by the block.
        :param goal: The block should stand on the goal tile vertically.
        :param col_sep: Separator between the str representation of the tiles in the same row (separates each col).
        :param row_sep: Separator between the str representation of the rows in a map.
        :return: Decoder to be used in initialization of game parameters
        """
        return {empty: 0,
                safe: 1,
                block: BloxorzGame._BLOCK_VAL,
                goal: BloxorzGame._GOAL_VAL,
                'col_sep': col_sep,
                'row_sep': row_sep
                }

    @staticmethod
    def validate_map(str_map, decoder=None):
        """
        Validate the str map given the decoder. If decoder is not given, default decoder returned by
        BloxorzGame.decoder_gen is used.
        :param str_map: map to be validated.
        :param decoder: decoder to be used in validation. Default decoder is used if not given.
        :return: True if valid, False otherwise.
        """
        # Set default decoder if not given
        decoder = decoder if decoder else BloxorzGame.decoder_gen()

        # CHECK IF RECTANGULAR: Remove delimiters and newlines to have a list of rows represented as string
        filtered_map = str_map.replace(decoder['col_sep'], '') \
            .split(decoder['row_sep'])
        # For rectangular map, number of tile in each row should be equal.
        for i in range(1, len(filtered_map)):
            if len(filtered_map[0]) != len(filtered_map[i]):
                return False    # Even one inequality is enough to be invalid.

        # CHECK NUMBER OF BLOCK TILES:
        if not 0 < str_map.count(
                list(decoder.keys())[list(decoder.values()).index(
                    BloxorzGame._BLOCK_VAL)]) < 3:
            return False

        # CHECK INVALID CHARACTERS:
        for key in decoder:
            # Remove all valid characters to see if any invalid character exists in the map
            str_map = str_map.replace(
                key if 'col_sep' != key != 'row_sep' else decoder[key],
                '')
        return not bool(len(str_map))  # Non-zero length indicate there exist at least one invalid char

    def __init__(self, game_map=None, decoder=None):
        """
        Initialize the game with the given string-represented map. If decoder is not given, default one is used to
        convert the string representation of the map into tiles. If the map does not use the default encoding,
        corresponding decoder should be passed. Custom decoders can be generated using BloxorzGame.get_decoder.
        If map is not given, game is initialized with empty parameters. Then, init_board should be used to finish
        the initialization of Problem parameters.
        :param game_map: rectangular, str map corresponding to the encoding generated by BloxorzGame.get_decoder.
        :param decoder: generated by BloxorzGame.get_decoder.
        """
        self._map = None
        self._decoder = decoder if decoder else BloxorzGame.decoder_gen()

        # Initial and goal states of the problem. Set to None by default. Problem already defines the class variables...
        problem_parameters = (None, None)
        if game_map:    # init Problem parameters and _map. Validity of the map will be checked in init_map.
            problem_parameters = self.init_map(game_map, self._decoder)

        Problem.__init__(self, *problem_parameters)

    def actions(self, state):
        pass

    def init_map(self, str_map, decoder=None):
        """
        Given a valid map where the validity can be checked using BloxorzGame.validate_map, determine the initial
        state and the goal(s if there are more than one). Raises ValueError if str_map is not valid.
        :param str_map: str map corresponding to the encoding generated by BloxorzGame.get_decoder.
        :param decoder: generated by BloxorzGame.get_decoder.
        :return: Initial state of the block, goal state
        """
        self._decoder = decoder if decoder else self._decoder   # In the worst case, _decoder is default via __init__.

        if not self.validate_map(str_map, self._decoder):
            raise ValueError('Str map contains invalid value(s) undeclared in the decoder or invalid initial state'
                             ' or it is not rectangular!')

        # Remove delimiters and newlines to have a list of rows represented as string
        filtered_map = str_map.replace(self._decoder['col_sep'], '') \
            .split(self._decoder['row_sep'])

        # Decode all characters in each row of the map forming a list of rows which are list of the tiles.
        self._map = [[self._decoder[char] for char in line] for line in filtered_map]

        initial = [None, None]     # Assume vertical at the origin
        goal = []
        for j in range(len(self._map)):
            # Check goal tile in current row.
            i = 0
            for k in range(self._map[j].count(BloxorzGame._GOAL_VAL)):
                # To find multiple goals in the same row, trim the search area including the previous goals
                i = self._map[j].index(BloxorzGame._GOAL_VAL, i+1)
                goal.append(((i, j), 3))

            # Check block tile(s)
            num_block_tiles = self._map[j].count(BloxorzGame._BLOCK_VAL)
            if num_block_tiles == 2:
                # The block is in x-direction
                initial = [(self._map[j].index(BloxorzGame._BLOCK_VAL), j), 1]
            elif not initial[0] and num_block_tiles == 1:
                i = self._map[j].index(BloxorzGame._BLOCK_VAL)
                # If initial[0] is None, this is the first time block-tile was encountered. For the first occurrence,
                # it is the position of the upper portion if aligned with y-axis or the position of the block if
                # aligned with z-axis. Either way it is the position of the block.
                initial[0] = (i, j)
                # If there is a block tile below, it is aligned with y-axis, otherwise with z-axis.
                if self._map[i][j+1] == BloxorzGame._BLOCK_VAL:
                    initial[1] = 2
                else:
                    initial[1] = 3

        # Convert to tuples since they won't change anymore.
        return tuple(initial), tuple(goal)

    def result(self, state, action):
        pass

    def value(self, state):
        pass
